## 点击事件

#### 实现方式

1.在 `UIResponder + BXLAnalytic.h` 分类中 利用 **关联对象** 增加属性 `actionEntity` 来记录点击数据:

```
@interface UIResponder (BXLAnalytic)

@property (nonatomic, strong) BXLUserActionEntity *actionEntity;

@end
```
2.在以下控件/对象的分类中进行方法交换,来 hook 响应事件. 在此处统一发送声明式设计的算法均基于方法交换: 

```
UIControl+BXLAnalytic.h
UICollectionView+BXLAnalytic.h
UITableView+BXLAnalytic.h
UIGestureRecognizer+BXLAnalytic.h
```

举个例子, 对UIControl进行事件交换:

```
@implementation UIControl (BXLAnalytic)

+ (void)initialize {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        SEL originalSelector = @selector(sendAction:to:forEvent:);
        SEL swizzledSelector = @selector(bxlSendAction:to:forEvent:);
        [self bxl_swizzleMethod:originalSelector withMethod:swizzledSelector];
    });
}

- (void)bxlSendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event {
    [self bxlSendAction:action to:target forEvent:event];
    if (self.actionEntity) {
        [XBorderAnalyticsWrapper trackingEvent:^(BXL5thAveUserInteraction *action) {
            action.userClick = self.actionEntity;
        }];
    }
}

@end
```

#### Demo

```
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    BXLShoppintCartGroupGatherTipModel *tipModel = [self.viewModel modelAtIndex:indexPath.row];
    BXLShoppingCartGroupGatherTipCell *cell = [tableView dequeueReusableCellWithIdentifier:NSStringFromClass(BXLShoppingCartGroupGatherTipCell.class)];
    cell.selectionStyle = UITableViewCellSelectionStyleNone;
    [cell setTextBullets:tipModel.tipText.tipText buttonBullets:tipModel.rightAdvice.tipText];
    
    cell.actionEntity = ({
        // clickTrack
        BXLUserActionEntity *click = [BXLUserActionEntity new];
        click.entityId = self.merchantId;
        click.viewType = [BXL5thAveDisplayLocation_EnumDescriptor() getEnumTextFormatNameForIndex:BXL5thAveDisplayLocation_DlSbgtv];
        click.primaryIndex = (int32_t)(indexPath.row + 1);
        click.content = [self stringWithArray:tipModel.tipText.tipText];
        click;
    });
    
    return cell;
}
```

## Impression事件

#### 实现方式

1.新建类 `BXLEventsAutoTracker` 继承自NSObject, 该类为单例;

```
@interface BXLEventsAutoTracker : NSObject

+ (instancetype)shareInstance;

@end

```

> 单例并不是必须的!

2.对外暴露开始Track和结束Track的接口:

```
- (void)trackingScroll:(nullable __kindof UIScrollView *)scrollView block:(TrackingBlock)block;

- (void)stopTrackingScroll:(nullable __kindof UIScrollView *)scrollView;
```

> 为什么要设计开始Track和结束Track两个接口?  
> 1.页面是有生命周期的, 当页面出现在屏幕上可以响应用户操作时,应该开始追踪; 当页面被隐藏或者不能接受用户操作时,应结束追踪!  
> 2.对于多tab页面, 当tab切出时应该停止追踪;当tab切入时, 应该开始追踪!  
> 3.结合滚动状态的设计,后续会讲.

3.监听滚动视图的滚动.这里主要采用KVO的设计并涉及到 KVOController 的使用, 关于KVOController请看 https://github.com/facebook/KVOController.

<img src="https://wisdom-doc.oss-cn-hangzhou.aliyuncs.com/img/code1.png">

我们将滚动过程分为三个状态: **开始滚动前**, **滚动中**, **滚动停止**.

结合这三个状态, 我们的逻辑主要有3部:

- 第7行, 对scrollView进行滚动前的初次tracking.
- 第11行, 使用KVO对ScrollView进行滚动监听.这里只能通过KVO的方式对ScrollView的滚动进行监听, 因为代理对象只能设置一个, 如果这里将scrollView.delegate设置为self,那么会移除已有的代理对象.
- 第17行, 存储回调的block,在滚动过程中和滚动停止时调用.

> 为什么要分为3个状态?  
> 1.用户进入一个页面时,可能不发生任何滑动操作,便会直接点击进入某模块落地页.  
> 2.用户可能突然滑动很快然后突然用手指触摸屏幕停止滑动, 而我们的tracking算法会检测用户的滚动速度, 超过一定的速度, 我们认为不是有效的真正的用户浏览.这也是要在滚动停止时再追踪一次的原因.  
> 3.正常的滑动意味着用户正常的浏览,需要track.

那么问题的核心便聚焦在以下几点:

- 如何监听ScrollView的停止滚动?
- 滚动时触发Tracking的时机.

4.如何监听 ScrollView 的停止滚动

很不幸, UIKit并没有直接高速我们UIScrollView停止滚动的时机. 这里也不能通过代理方法来控制.
我们在网上找到了一种取巧的方案:

```
- (void)subscribeScrollViewScrolling:(id)obj {
    if ([obj isKindOfClass:UIScrollView.class]) {
        UIScrollView *scrollView = (UIScrollView *)obj;
        __weak typeof(scrollView) weakScrollView = scrollView;
        if (!weakScrollView) {
            return;
        }
        NSString *key = [NSString stringWithFormat:@"%p", scrollView];
        TrackingBlock block = [self.scrollDict valueForKey:key];
        [scrollView impressionLogWhenScrolling:YES tracking:[block copy]];
        [self debounce:@selector(scrollViewDidEndScroll:) object:scrollView delay:0];
    }
}

- (void)scrollViewDidEndScroll:(UIScrollView *)scrollView {
    NSString *key = [NSString stringWithFormat:@"%p", scrollView];
    TrackingBlock block = [self.scrollDict valueForKey:key];
    [scrollView impressionLogWhenScrolling:NO tracking:block];
}

```

在ScrollView滚动频繁触发`subscribeScrollViewScrolling` 时,我们向当前runloop里面注册一个延时调用的方法, 每次注册之前先将已经注册的方法从runloop里面移除.这样最终在停止滚动时, 当前runloop里其实就只剩一次注册, 它会在滚动停止时调用.

> 详细请看官方文档  
> [- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;](https://developer.apple.com/documentation/objectivec/nsobject/1416176-performselector?language=objc)  
> [+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;
](https://developer.apple.com/documentation/objectivec/nsobject/1417611-cancelpreviousperformrequestswit?language=objc)


5.滚动时触发Tracking的时机

对于滚动前的状态, 例如刚进入页面时, 显示在屏幕上的模块都应该被Tracking. 所以对于滚动前, 只要满足模块有足够的区域显示在屏幕上,就应该触发tracking.这个足够的区域, 我们拍脑袋决定为40%的区域.下面我们来看看代码, tracking的算法过程封装在了 `UIScrollView+BXLAnalytic.h` 分类中.

<img src="https://wisdom-doc.oss-cn-hangzhou.aliyuncs.com/img/code2.png">

请看第 2-12 行code:

首先通过isScrolling参数来判断ScrollView当前是否处于滚动状态, 滚动前和滚动停止后的逻辑是一致的, 只要满足模块有足够的区域显示在屏幕上,就应该触发tracking.所以只需要判断当前scrollView是否在屏幕上, 以及是否在后台, 如果是直接return即可. 如果满足tracking的条件, 那么获取屏幕上模块的indexPath即可.即:

```
// 获取屏幕上满足要求的indexPaths
NSArray *visiblePaths = [self getVisiablePaths];

// 对这些indexPaths进行log
[self logExpressionForPaths:visiblePaths data:block];
```

`getVisiablePaths` 的实现方式为:

```
- (NSArray *)getVisiablePaths {
    NSMutableArray *visiblePaths = [NSMutableArray array];
    if ([self isKindOfClass:[UITableView class]]) {
        UITableView *tableView = (UITableView *)self;
        for (NSIndexPath *path in tableView.indexPathsForVisibleRows) {
            CGRect cellRect = [tableView rectForRowAtIndexPath:path];
            if ([self isCellVisiableAreaEnoughToLog:cellRect scrollViewBounds:tableView.bounds]) {
                [visiblePaths addObject:path];
            }
        }
    } else if([self isKindOfClass:[UICollectionView class]]) {
        UICollectionView *collectionView = (UICollectionView *)self;
        for (NSIndexPath *path in collectionView.indexPathsForVisibleItems) {
            CGRect cellRect = [collectionView layoutAttributesForItemAtIndexPath:path].frame;
            if ([self isCellVisiableAreaEnoughToLog:cellRect scrollViewBounds:collectionView.bounds]) {
                [visiblePaths addObject:path];
            }
        }
    }
    return [visiblePaths copy];
}
```

其中注意 `isCellVisiableAreaEnoughToLog:scrollViewBounds:` 即为判断cell是否满足展现在屏幕上的方法.

`logExpressionForPaths:data:` 里面的内容:

```
- (void)logExpressionForPaths:(NSArray *)visiblePaths data:(TrackingBlock)block {
    if (!self.visibleIndexPathBuffer) {
        self.visibleIndexPathBuffer = @[];
    }

    if (visiblePaths && visiblePaths.count > 0 ) {
        NSMutableArray *filteredPaths = [NSMutableArray array];
        for (NSIndexPath *p in visiblePaths) {
            if (!self.visibleIndexPathBuffer || ![self.visibleIndexPathBuffer containsObject:p]) {
                [filteredPaths addObject:p];
                [self subscribeCellAtIndexPath:p];
            }
        }
        
        if (block) {
            NSArray<BXL5thAveUserInteraction *> *interactions = block(filteredPaths);
            for (BXL5thAveUserInteraction *interaction in interactions) {
                NSString *propertyName = [interaction.descriptor fieldWithNumber:interaction.eventDetailOneOfCase].name;
                if (!interaction || !VALID_STRING(propertyName)) {
                    continue;
                }
                [XBorderAnalyticsWrapper trackingEventInteraction:interaction];
            }
        }
        self.visibleIndexPathBuffer = [visiblePaths copy];
    }
}
```

其中需要注意的是 `visibleIndexPathBuffer` 这个关联对象的作用.  

`self.visibleIndexPathBuffer = [visiblePaths copy];`   

因为每一次log都将会其用来记录上一次log的visible indexPaths, 避免了indexPath的重复发送.

而其中 `subscribeCellAtIndexPath` 是一种通知机制, 详细代码如下:

```
- (void)subscribeCellAtIndexPath:(NSIndexPath *)indexPath {
    if ([self isKindOfClass:UICollectionView.class]) {
        UICollectionView *collectionView = (UICollectionView *)self;
        UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];
        if ([cell conformsToProtocol:@protocol(BXLModuleOnScreenTrackingProtocol)]) {
            if ([cell respondsToSelector:@selector(BXLTracking_cellOnScreen:)]) {
                [cell performSelector:@selector(BXLTracking_cellOnScreen:) withObject:indexPath];
            }else if ([cell respondsToSelector:@selector(BXLTracking_cellOnScreen)]) {
                [cell performSelector:@selector(BXLTracking_cellOnScreen) withObject:nil];
            }
        }
    }else if ([self isKindOfClass:UITableView.class]) {
        UITableView *tableView = (UITableView *)self;
        UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
        if ([cell conformsToProtocol:@protocol(BXLModuleOnScreenTrackingProtocol)]) {
            if ([cell respondsToSelector:@selector(BXLTracking_cellOnScreen:)]) {
                [cell performSelector:@selector(BXLTracking_cellOnScreen:) withObject:indexPath];
            }else if ([cell respondsToSelector:@selector(BXLTracking_cellOnScreen)]) {
                [cell performSelector:@selector(BXLTracking_cellOnScreen) withObject:nil];
            }
        }
    }
}

```

即, 如果Cell遵守并实现了 `BXLModuleOnScreenTrackingProtocol` 协议中的方法, 那么在触发track条件时, 会通知到响应的那些cell.

6.滚动过程中的log

让我们再看上面第13-27行code,主要是对track的频率和速度进行了判断和限制.因为该方法的调用很频繁.

限制条件为 `MAX(屏幕最大长度的1/10, 20pt)`, (拍脑袋决定的).

#### Demo

搜索页面商品的impression log

```
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    [self impressionTracking];
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    [self stopImpressionTracking];
}


- (void)impressionTracking {
    [[BXLEventsAutoTracker shareInstance] trackingScroll:self.productListView.collView block:^NSArray<BXL5thAveUserInteraction *> * _Nullable(NSArray<NSIndexPath *> * _Nullable indexPaths) {
        if (!indexPaths.count) {
            return @[];
        }
        BXL5thAveUserInteraction *interaction = [BXL5thAveUserInteraction message];
        BXL5thAveProductListImpressionLog *prodImpressionLog = [BXL5thAveProductListImpressionLog message];
        for (NSIndexPath *indexPath in indexPaths) {
            BXL5thAveProdImpressionLogItem *logItem = [[BXL5thAveProdImpressionLogItem alloc] init];
            logItem.previousPage = self.previousPage;
            logItem.currentPage = self.currentPage;
            logItem.currentQuery = self.flowViewModel.queryString;
            id viewModel = nil;
            if (indexPath.item < self.flowViewModel.listViewModels.count) {
                viewModel = [self.flowViewModel.listViewModels objectAtIndex:indexPath.item];
            } else {
                NSLog(@"wow 越界了");
            }
            if ([viewModel isKindOfClass:[BXLProductsRecommendedProductViewModel class]]) {
                BXLProductsRecommendedProductViewModel *vm = (BXLProductsRecommendedProductViewModel *)viewModel;
                logItem.productId = vm.productId;
                logItem.index = (int32_t)indexPath.item + 1;
                [prodImpressionLog.logItemArray addObject:logItem];
            } else if ([viewModel isKindOfClass:[BXLProductsRecommendedGatherProductViewModel class]]) {
                BXLProductsRecommendedGatherProductViewModel *vm = (BXLProductsRecommendedGatherProductViewModel *)viewModel;
                logItem.productId = vm.listProductVM.productId;
                logItem.index = (int32_t)indexPath.item + 1;
                [prodImpressionLog.logItemArray addObject:logItem];
            }
        }
        if ([self.flowViewModel.searchParams.pageType isEqualToString:@"GATHER"]) {
            prodImpressionLog.listStyle = BXL5thAveListStyle_Gather;
        } else {
            prodImpressionLog.listStyle = BXL5thAveListStyle_New;
        }
        prodImpressionLog.previousPage = self.previousPage;
        prodImpressionLog.currentPage = self.currentPage;
        interaction.prodImpressionLog = prodImpressionLog;
        interaction.entityAction.displayLocation = BXL5thAveDisplayLocation_DlPlpv2;
        interaction.entityAction.userAction = BXL5thAveUserAction_UserActionImpression;
        interaction.entityAction.productIdsArray = [prodImpressionLog.logItemArray arrayWithMap:^id _Nonnull(BXL5thAveProdImpressionLogItem * _Nonnull obj, NSUInteger idx) {
            return obj.productId;
        }];
        if (prodImpressionLog.logItemArray_Count == 0) {
            return @[];
        }
        return @[interaction];
    }];
}

- (void)stopImpressionTracking {
    [[BXLEventsAutoTracker shareInstance] stopTrackingScroll:self.productListView.collView];
}
```


















