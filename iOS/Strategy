
我们将App中的Address类简化, 用3个字段举例

```
@interface Address : NSObject

@property (nonatomic, copy) NSString *country;
@property (nonatomic, copy) NSString *lastName;
@property (nonatomic, copy) NSString *firstName;

@end
```

定义fullName为lastName和firstName的拼接,
但是用户可以选择两个国家: US 和 China. 我们知道中美两国的姓名格式是不一样的, 比如用户的姓名为: "Tony Zhang", 
当用户选择的国家为 `US` 时, 输出的fullName应该"Tony Zhang",
当用户选择的国家为 `China` 时, 输出fullName应该为"Zhang Tony".

如果不使用策略模式时, 我们先来看看if-else下的代码:

```
    if ([address.country isEqualToString:@"US"]) {
        NSLog(@"%@ %@", address.firstName, address.lastName);
    }else if ([address.country isEqualToString:@"China"]) {
        NSLog(@"%@ %@", address.lastName, address.firstName);
    }
```

在该例子下, if-else的逻辑还不算多, 设想如果在地址功能下还有其他的逻辑也需要根据不同国家来区别对待,
甚至增加一个国家地区的时候,代码里就会充满各种各样零散的if-else逻辑,维护的成本也会随之增高.


那么我们看看如果使用策略模式, 是不是能很好的解决这个问题呢.

### 什么是策略模式?



首先,我们可以利用协议来抽象具体使用策略的行为. 在该例子当中,也就是根据用户选择的国家返回不一样的fullName.
那么我们可以把获取fullName这个行为定义成一个抽象接口:

```
@class Address;
@protocol AddressStrategy <NSObject>

- (NSString *)fullName:(Address *)address;

@end
```

策略的执行层, 执行层的作用是: 你给我一个策略,我给你这个策略返回的结果:

```
@interface AddressHelper : NSObject

- (instancetype)initWithStrategy:(id<AddressStrategy>)strategy;
- (NSString *)getFullName:(Address *)address;

@end



@interface AddressHelper ()

@property (nonatomic, strong) id<AddressStrategy> strategy;

@end

@implementation AddressHelper

- (instancetype)initWithStrategy:(id<AddressStrategy>)strategy {
    if (self = [super init]) {
        self.strategy = strategy;
    }
    return self;
}

- (NSString *)getFullName:(Address *)address {
    return [self.strategy fullName:address];
}

@end
```

策略的实现层:

中国地址策略实现层
```
#import "AddressStrategy.h"
@interface ChinaAddressStrategy : NSObject<AddressStrategy>
@end

@implementation ChinaAddressStrategy

- (NSString *)fullName:(Address *)address {
    return [address.lastName stringByAppendingFormat:@" %@", address.firstName];
}

@end

```

美国地址策略实现层
```

#import "AddressStrategy.h"
@interface USAddressStrategy : NSObject<AddressStrategy>
@end


#import "USAddressStrategy.h"
#import "Address.h"

@implementation USAddressStrategy

- (NSString *)fullName:(Address *)address {
    return [address.firstName stringByAppendingFormat:@" %@", address.lastName];
}

@end
```

那么,我在使用的时候,直接调用策略的实现层即可:

```
AddressHelper *helper = [[AddressHelper alloc] initWithStrategy:[USAddressStrategy new]];
NSLog(@"%@", [helper getFullName:address]);
    
    
AddressHelper *helper2 = [[AddressHelper alloc] initWithStrategy:[ChinaAddressStrategy new]];
NSLog(@"%@", [helper2 getFullName:address]);

```

你看, ViewController中的代码变得更精简了, 不同国家的获取不同fullName的逻辑被抽离出ViewController而内聚在了自己国家的策略实现层当中.



